{
  "name": "Scrape LeaseBreak NYC Listings",
  "nodes": [
    {
      "parameters": {
        "rule": {
          "interval": [{ "field": "hours", "hoursInterval": 6 }]
        }
      },
      "id": "schedule",
      "name": "Every 6 Hours",
      "type": "n8n-nodes-base.scheduleTrigger",
      "typeVersion": 1.2,
      "position": [0, 0]
    },
    {
      "parameters": {
        "jsCode": "const puppeteer = require('puppeteer-extra');\nconst StealthPlugin = require('puppeteer-extra-plugin-stealth');\npuppeteer.use(StealthPlugin());\n\nconst https = require('https');\n\nconst normalizeDate = (input) => {\n  if (!input || typeof input !== 'string') return null;\n  const cleaned = input.trim();\n  if (!cleaned) return null;\n  const parsed = new Date(cleaned);\n  if (Number.isNaN(parsed.getTime())) return null;\n  return parsed.toISOString().slice(0, 10);\n};\n\n// Fetch free proxy list\nconst fetchProxies = () => new Promise((resolve) => {\n  https.get('https://api.proxyscrape.com/v4/free-proxy-list/get?request=display_proxies&protocol=http&proxy_format=protocolipport&format=text&anonymity=elite,anonymous&timeout=5000&country=us,ca,gb,de,fr,nl', (res) => {\n    let data = '';\n    res.on('data', (chunk) => data += chunk);\n    res.on('end', () => {\n      const proxies = data.split('\\n').map(p => p.trim()).filter(p => p.startsWith('http'));\n      resolve(proxies.slice(0, 15));\n    });\n  }).on('error', () => resolve([]));\n});\n\nconst proxies = await fetchProxies();\n\nconst tryWithProxy = async (proxy) => {\n  const args = [\n    '--no-sandbox',\n    '--disable-setuid-sandbox',\n    '--disable-dev-shm-usage',\n    '--disable-blink-features=AutomationControlled'\n  ];\n  if (proxy) args.push(`--proxy-server=${proxy}`);\n\n  const browser = await puppeteer.launch({\n    headless: 'new',\n    executablePath: process.env.PUPPETEER_EXECUTABLE_PATH || '/usr/bin/chromium-browser',\n    args\n  });\n\n  try {\n    const page = await browser.newPage();\n    await page.setViewport({ width: 1366, height: 768 });\n    await page.setExtraHTTPHeaders({ 'Accept-Language': 'en-US,en;q=0.9' });\n\n    const listings = [];\n\n    for (let pageNum = 1; pageNum <= 3; pageNum++) {\n      const url = `https://www.leasebreak.com/listings?city=new-york&page=${pageNum}`;\n      const resp = await page.goto(url, { waitUntil: 'networkidle2', timeout: 30000 });\n      if (!resp || resp.status() === 403) throw new Error('403 blocked');\n\n      // Wait for any content to load\n      await page.waitForSelector('a[href*=\"/listing\"], a[href*=\"/property\"], [class*=card], [class*=Card]', { timeout: 12000 }).catch(() => null);\n\n      // Debug: capture page title and body length\n      const debugInfo = await page.evaluate(() => ({\n        title: document.title,\n        bodyLen: document.body?.innerHTML?.length || 0,\n        allLinks: Array.from(document.querySelectorAll('a[href]')).map(a => a.getAttribute('href')).filter(h => h && (h.includes('/listing') || h.includes('/property'))).slice(0, 5)\n      }));\n\n      const pageListings = await page.evaluate(() => {\n        const items = [];\n        // Grab all internal links that look like listings\n        const allAnchors = document.querySelectorAll('a[href*=\"/listing\"], a[href*=\"/property\"], a[href*=\"/lease\"]');\n        // Also try card-style containers\n        const cards = document.querySelectorAll('[class*=listing], [class*=Listing], [class*=card], [class*=Card], [class*=property], [class*=Property]');\n\n        const processElement = (el) => {\n          const anchor = el.tagName === 'A' ? el : el.querySelector('a[href]');\n          if (!anchor) return null;\n          const href = anchor.getAttribute('href');\n          if (!href || href === '#' || href === '/') return null;\n          const fullUrl = href.startsWith('http') ? href : `https://www.leasebreak.com${href}`;\n          if (!fullUrl.includes('leasebreak.com')) return null;\n\n          const container = el.closest('[class*=card], [class*=Card], [class*=listing], [class*=Listing]') || el;\n          const text = (container.textContent || '').replace(/\\s+/g, ' ').trim();\n\n          // Title: try headings first, then the anchor text\n          const titleEl = container.querySelector('h1, h2, h3, h4, h5, [class*=title], [class*=Title], [class*=address], [class*=Address], [class*=name], [class*=Name]');\n          const title = titleEl?.textContent?.trim() || anchor.textContent?.trim() || text.substring(0, 100);\n\n          // Price\n          const priceEl = container.querySelector('[class*=price], [class*=Price], [class*=rent], [class*=Rent], [class*=cost], [class*=Cost]');\n          const priceText = priceEl?.textContent || text;\n          const priceMatch = priceText.match(/\\$([\\d,]+)/);\n          const price = priceMatch ? parseInt(priceMatch[1].replace(/,/g, ''), 10) : null;\n\n          // Bedrooms\n          const brMatch = text.match(/(\\d+)\\s*(?:bed|br|bedroom)/i) || text.match(/studio/i);\n          const bedrooms = brMatch ? (brMatch[0].toLowerCase().includes('studio') ? 0 : parseInt(brMatch[1], 10)) : null;\n\n          // Location\n          const locEl = container.querySelector('[class*=neighborhood], [class*=Neighborhood], [class*=location], [class*=Location], [class*=area], [class*=Area]');\n          const neighborhood = locEl?.textContent?.trim() || null;\n\n          // Lease end date\n          const dateMatch = text.match(/(?:lease\\s*end|available\\s*(?:until|through)|ends?|move.?out)\\s*:?\\s*(\\d{1,2}\\/\\d{1,2}\\/\\d{2,4}|(?:jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)\\w*\\s+\\d{1,2},?\\s*\\d{4})/i);\n          const leaseEndDate = dateMatch ? dateMatch[1] : null;\n\n          // External ID from URL slug\n          const slugMatch = fullUrl.match(/\\/(?:listing|property|lease)[s]?\\/([^/?#]+)/);\n          const externalId = slugMatch ? slugMatch[1] : null;\n\n          if (title && title.length > 3 && fullUrl.includes('leasebreak.com/')) {\n            return { url: fullUrl, title, price, bedrooms, neighborhood, lease_end_date: leaseEndDate, external_id: externalId };\n          }\n          return null;\n        };\n\n        // Process cards first, then loose anchors\n        const seen = new Set();\n        [...cards, ...allAnchors].forEach(el => {\n          const item = processElement(el);\n          if (item && !seen.has(item.url)) {\n            seen.add(item.url);\n            items.push(item);\n          }\n        });\n\n        return items;\n      });\n\n      listings.push(...pageListings);\n      if (pageListings.length === 0 && debugInfo.allLinks.length === 0) break; // no more pages\n      await new Promise(r => setTimeout(r, 1500));\n    }\n\n    await browser.close();\n    return listings;\n  } catch (err) {\n    await browser.close();\n    throw err;\n  }\n};\n\n// Try direct first, then proxies\nlet items = [];\nconst attempts = [null, ...proxies];\nlet lastError = '';\n\nfor (const proxy of attempts) {\n  try {\n    items = await tryWithProxy(proxy);\n    if (items.length > 0) break;\n  } catch (err) {\n    lastError = `${proxy || 'direct'}: ${err.message}`;\n    continue;\n  }\n}\n\nif (items.length === 0) {\n  return [{ json: { _skip: true, error: lastError || 'No results from any proxy', proxies_tried: attempts.length } }];\n}\n\n// Deduplicate\nconst seen = new Set();\nconst unique = items.filter(l => {\n  if (!l.url || seen.has(l.url)) return false;\n  seen.add(l.url);\n  return true;\n});\n\nconst output = unique.map(l => {\n  let borough = null;\n  const nh = (l.neighborhood || l.title || '').toLowerCase();\n  if (/manhattan|midtown|harlem|village|soho|tribeca|chelsea|uws|ues|les|fidi|murray hill|gramercy/.test(nh)) borough = 'Manhattan';\n  else if (/brooklyn|williamsburg|bushwick|bed-stuy|park slope|crown heights|greenpoint|flatbush|dumbo/.test(nh)) borough = 'Brooklyn';\n  else if (/queens|astoria|lic|long island city|flushing|jackson heights/.test(nh)) borough = 'Queens';\n  else if (/bronx|riverdale|fordham|mott haven/.test(nh)) borough = 'Bronx';\n  else if (/staten island/.test(nh)) borough = 'Staten Island';\n\n  return {\n    json: {\n      source: 'leasebreak',\n      external_id: l.external_id,\n      url: l.url,\n      title: l.title,\n      price: l.price,\n      bedrooms: l.bedrooms,\n      neighborhood: l.neighborhood,\n      borough,\n      lease_type: 'lease_break',\n      lease_end_date: normalizeDate(l.lease_end_date),\n      is_active: true\n    }\n  };\n});\n\nreturn output;"
      },
      "id": "scrape_lb",
      "name": "Scrape LeaseBreak (Stealth + Proxy)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [220, 0]
    },
    {
      "parameters": {
        "conditions": {
          "options": { "caseSensitive": false },
          "combinator": "and",
          "conditions": [
            {
              "leftValue": "={{ $json._skip }}",
              "rightValue": true,
              "operator": { "type": "boolean", "operation": "notEqual" }
            }
          ]
        }
      },
      "id": "filter_empty",
      "name": "Filter Empty",
      "type": "n8n-nodes-base.filter",
      "typeVersion": 2,
      "position": [440, 0]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "INSERT INTO scraped_listing (source, external_id, url, title, price, bedrooms, neighborhood, borough, lease_type, lease_end_date, is_active, last_seen_at, raw_data) VALUES ('{{ $json.source }}', {{ $json.external_id ? \"'\" + $json.external_id + \"'\" : 'NULL' }}, '{{ $json.url.replace(/'/g, \"''\") }}', '{{ $json.title.replace(/'/g, \"''\") }}', {{ $json.price || 'NULL' }}, {{ $json.bedrooms ?? 'NULL' }}, {{ $json.neighborhood ? \"'\" + $json.neighborhood.replace(/'/g, \"''\") + \"'\" : 'NULL' }}, {{ $json.borough ? \"'\" + $json.borough + \"'\" : 'NULL' }}, {{ $json.lease_type ? \"'\" + $json.lease_type + \"'\" : 'NULL' }}, {{ $json.lease_end_date ? \"'\" + $json.lease_end_date + \"'\" : 'NULL' }}, true, now(), '{{ JSON.stringify($json).replace(/'/g, \"''\") }}'::jsonb) ON CONFLICT (url) DO UPDATE SET external_id = COALESCE(EXCLUDED.external_id, scraped_listing.external_id), title = EXCLUDED.title, price = COALESCE(EXCLUDED.price, scraped_listing.price), bedrooms = COALESCE(EXCLUDED.bedrooms, scraped_listing.bedrooms), neighborhood = COALESCE(EXCLUDED.neighborhood, scraped_listing.neighborhood), borough = COALESCE(EXCLUDED.borough, scraped_listing.borough), lease_type = COALESCE(EXCLUDED.lease_type, scraped_listing.lease_type), lease_end_date = COALESCE(EXCLUDED.lease_end_date, scraped_listing.lease_end_date), is_active = true, last_seen_at = now(), raw_data = EXCLUDED.raw_data, updated_at = now()",
        "options": {}
      },
      "id": "insert_db",
      "name": "Upsert to Neon",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.5,
      "position": [660, 0],
      "credentials": {
        "postgres": { "id": "CONFIGURE_ME", "name": "Neon PostgreSQL" }
      }
    }
  ],
  "connections": {
    "Every 6 Hours": { "main": [[{ "node": "Scrape LeaseBreak (Stealth + Proxy)", "type": "main", "index": 0 }]] },
    "Scrape LeaseBreak (Stealth + Proxy)": { "main": [[{ "node": "Filter Empty", "type": "main", "index": 0 }]] },
    "Filter Empty": { "main": [[{ "node": "Upsert to Neon", "type": "main", "index": 0 }]] }
  },
  "settings": { "executionOrder": "v1" }
}
